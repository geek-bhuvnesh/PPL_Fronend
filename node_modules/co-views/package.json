{
  "name": "co-views",
  "version": "2.0.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/tj/co-views"
  },
  "description": "Higher level promise-based template rendering for Co and others, built on co-render",
  "keywords": [
    "template",
    "render",
    "consolidate",
    "engine",
    "koa"
  ],
  "files": [
    "index.js"
  ],
  "dependencies": {
    "co-render": "1",
    "debug": "2",
    "utils-merge": "1"
  },
  "devDependencies": {
    "co": "4",
    "ejs": "2",
    "hogan.js": "3",
    "jade": "1",
    "mocha": "2",
    "swig": "1"
  },
  "license": "MIT",
  "readme": "# co-views\n\n  Template rendering for [co](https://github.com/tj/co) using\n  [co-render](https://github.com/tj/co-render). This module\n  provides higher level sugar than co-render to reduce redundancy,\n  for example specifying a views directory and default extension name.\n\n## Installation\n\n```\n$ npm install co-views\n```\n\n And install whichever engine(s) you use:\n\n```\n$ npm install ejs jade\n```\n\n## Options\n\n - `map` an object mapping extension names to engine names [`{}`]\n - `default` default extension name to use when missing [`html`]\n - `cache` cached compiled functions [NODE_ENV != 'development']\n\n### map\n\n  For example if you wanted to use \"swig\" for .html files\n  you would simply pass:\n\n```js\n{ map: { html: 'swig' } }\n```\n\n### default\n\n  Set the default template extension when none is passed to\n  the render function. This defaults to \"html\". For example\n  if you mostly use Jade, then you'd likely want to assign\n  this to:\n\n```js\n{ default: 'jade' }\n```\n\n  Allowing you to invoke `render('user')` instead of\n  `render('user.jade')`.\n\n### cache\n\n  When __true__ compiled template functions will be cached in-memory,\n  this prevents subsequent disk i/o, as well as the additional compilation\n  step that most template engines peform. By default this is _enabled_\n  when the __NODE_ENV__ environment variable is anything _but_ \"development\",\n  such as \"stage\" or \"production\".\n\n## Example\n\n  Render several users with different template engines in parallel. View\n  lookup is performed relative to the `./examples` directory passed,\n  and the \"swig\" engine is mapped to \".html\" files.\n\n```js\nvar co = require('co');\nvar views = require('co-views');\n\nvar render = views('examples', {\n  map: { html: 'swig' }\n});\n\nvar tobi = {\n  name: 'tobi',\n  species: 'ferret'\n};\n\nvar loki = {\n  name: 'loki',\n  species: 'ferret'\n};\n\nvar luna = {\n  name: 'luna',\n  species: 'cat'\n};\n\nco(function *(){\n  var a = render('user', { user: tobi });\n  var b = render('user.jade', { user: loki });\n  var c = render('user.ejs', { user: luna });\n  var html = yield [a, b, c];\n  html = html.join('');\n  console.log(html);\n});\n```\n\n## App-wide views\n\n  Dependending on your choice of application structure, you may wish to\n  share these same settings between all of your application, instead of\n  constantly initializing co-views. To do this simply create a `views.js`\n  module and export the render function returned:\n\n```js\nvar views = require('co-views');\n\nmodule.exports = views('views', {\n  map: {\n    html: 'swig',\n    md: 'hogan'\n  }\n});\n```\n\n# License\n\n  MIT\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/tj/co-views/issues"
  },
  "_id": "co-views@2.0.0",
  "dist": {
    "shasum": "eb932f4c1c5972c7334625388810b68efc12df5b"
  },
  "_from": "co-views@",
  "_resolved": "https://registry.npmjs.org/co-views/-/co-views-2.0.0.tgz"
}
